+++
title = "Musical notation and programming languages"
slug = "musical-notation-and-programming-languages"
url = "/2010/09/08/musical-notation-and-programming-languages"
date = "2010-09-08T10:12:41.000Z"
+++

The most recent assignment for my CS 330 class was to write about how musical notation is similar to a programming language. This is a fascinating idea that I had never considered before.

The professor had an <a href="http://faculty.cs.byu.edu/~jay/courses/2010/fall/330/course/music.html">odd grading system</a> for this assignment that, while seeking to reward creativity, penalizes collaboration, even in the mere exchange of ideas. But now that it's been graded and returned, I have no qualms with sharing it here. You may find it interesting.

## Similarities between musical notation and programming languages

Musical notation (in its modern form, at least) is standardized and widely accepted. Any educated performer can look at a piece of music and understand what the notation is intended to convey. This is a fundamental requirement of any programming language as well—the language must have a well-defined structure and syntax to be useful for expressing algorithms.

In addition to being systematic, musical notation is (largely) deterministic. While some structures in music are subject to the performer's interpretation (rubato is a prime example), most parts of the notation are straightforward and not open to much variation. This is a bit of a rough comparison, however, as programming languages are entirely devoid of human interpretation or variation. Any given piece of code written in a particular language produces the same behavior when properly compiled, regardless of the platform or environment.

A beautiful aspect of music is the fact that the same simple notes and pitches can be combined in infinitely many ways to produce new and interesting melodies. The creators of musical notation could have had no concept of all the types of music that would eventually be written with that notation. In the same way, a programming language can become the vehicle of expression for all sorts of programs that the creator of the language may or may not have envisioned. The predicates, control structures, and definitions can be combined in infinitely many ways to produce new and interesting programs.

Often, there is more than one way to notate a certain musical phrase. For example, one could write a series of 32<sup>nd</sup> notes of alternating pitches, specifying explicitly how a trill is to be performed. But more efficiently, the composer could write a single note with the symbol “tr” above it, signifying to the performer that she should execute that same series of alternating pitches, even though the composer did not expressly write them. In either case, the music produced is the same, but the latter notation is more concise and easy to understand. Many programming languages give the programmer similar facilities. He can write a function recursively or iteratively, for example. In one case, the recursive structure will be much more easily understood than its iterative analog, and in another case the iterative structure is more intuitive. Obviously, the result will be the same in the end. It is often left to a compiler to decide the most efficient way of actually executing the algorithm, regardless of what notation the programmer chose to express it.
